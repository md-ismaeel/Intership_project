var e = require('react');

const c=e=>"number"==typeof e&&!isNaN(e),d=e=>"string"==typeof e,u=e=>"function"==typeof e,m=e$1=>e.isValidElement(e$1)||d(e$1)||u(e$1)||c(e$1);const v=new Map;let h=[];const T=new Set,b=()=>v.size>0;function I(e,t){var n;if(t)return !(null==(n=v.get(t))||!n.isToastActive(e));let o=!1;return v.forEach(t=>{t.isToastActive(e)&&(o=!0);}),o}function _(e,t){m(e)&&(b()||h.push({content:e,options:t}),v.forEach(n=>{n.buildToast(e,t);}));}function C(e,t){v.forEach(n=>{null!=t&&null!=t&&t.containerId?(null==t?void 0:t.containerId)===n.id&&n.toggle(e,null==t?void 0:t.id):n.toggle(e,null==t?void 0:t.id);});}let w=1;const k=()=>""+w++;function P(e){return e&&(d(e.toastId)||c(e.toastId))?e.toastId:k()}function M(e,t){return _(e,t),t.toastId}function O(e,t){return {...t,type:t&&t.type||e,toastId:P(t)}}function x(e){return (t,n)=>M(t,O(e,n))}function A(e,t){return M(e,O("default",t))}A.loading=(e,t)=>M(e,O("default",{isLoading:!0,autoClose:!1,closeOnClick:!1,closeButton:!1,draggable:!1,...t})),A.promise=function(e,t,n){let o,{pending:s,error:a,success:r}=t;s&&(o=d(s)?A.loading(s,n):A.loading(s.render,{...n,...s}));const i={isLoading:null,autoClose:null,closeOnClick:null,closeButton:null,draggable:null},l=(e,t,s)=>{if(null==t)return void A.dismiss(o);const a={type:e,...i,...n,data:s},r=d(t)?{render:t}:t;return o?A.update(o,{...a,...r}):A(r.render,{...a,...r}),s},c=u(e)?e():e;return c.then(e=>l("success",r,e)).catch(e=>l("error",a,e)),c},A.success=x("success"),A.info=x("info"),A.error=x("error"),A.warning=x("warning"),A.warn=A.warning,A.dark=(e,t)=>M(e,O("default",{theme:"dark",...t})),A.dismiss=function(e){!function(e){var t;if(b()){if(null==e||d(t=e)||c(t))v.forEach(t=>{t.removeToast(e);});else if(e&&("containerId"in e||"id"in e)){const t=v.get(e.containerId);t?t.removeToast(e.id):v.forEach(t=>{t.removeToast(e.id);});}}else h=h.filter(t=>null!=e&&t.options.toastId!==e);}(e);},A.clearWaitingQueue=function(e){void 0===e&&(e={}),v.forEach(t=>{!t.props.limit||e.containerId&&t.id!==e.containerId||t.clearQueue();});},A.isActive=I,A.update=function(e,t){void 0===t&&(t={});const n=((e,t)=>{var n;let{containerId:o}=t;return null==(n=v.get(o||1))?void 0:n.toasts.get(e)})(e,t);if(n){const{props:o,content:s}=n,a={delay:100,...o,...t,toastId:t.toastId||e,updateId:k()};a.toastId!==e&&(a.staleId=e);const r=a.render||s;delete a.render,M(r,a);}},A.done=e=>{A.update(e,{progress:1});},A.onChange=function(e){return T.add(e),()=>{T.delete(e);}},A.play=e=>C(!0,e),A.pause=e=>C(!1,e);

function useNotificationCenter(params) {
  if (params === void 0) {
    params = {};
  }

  const sortFn = e.useRef(params.sort || defaultSort);
  const filterFn = e.useRef(params.filter || null);
  const [notifications, setNotifications] = e.useState(() => {
    if (params.data) {
      return filterFn.current ? params.data.filter(filterFn.current).sort(sortFn.current) : [...params.data].sort(sortFn.current);
    }

    return [];
  });
  e.useEffect(() => {
    return A.onChange(item => {
      if (item.status === 'added' || item.status === 'updated') {
        const newItem = decorate(item);
        if (filterFn.current && !filterFn.current(newItem)) return;
        setNotifications(prev => {
          let nextState = [];
          const updateIdx = prev.findIndex(v => v.id === newItem.id);

          if (updateIdx !== -1) {
            nextState = prev.slice();
            Object.assign(nextState[updateIdx], newItem, {
              createdAt: Date.now()
            });
          } else if (prev.length === 0) {
            nextState = [newItem];
          } else {
            nextState = [newItem, ...prev];
          }

          return nextState.sort(sortFn.current);
        });
      }
    });
  }, []);

  const remove = id => {
    setNotifications(prev => prev.filter(Array.isArray(id) ? v => !id.includes(v.id) : v => v.id !== id));
  };

  const clear = () => {
    setNotifications([]);
  };

  const markAllAsRead = function (read) {
    if (read === void 0) {
      read = true;
    }

    setNotifications(prev => prev.map(v => {
      v.read = read;
      return v;
    }));
  };

  const markAsRead = function (id, read) {
    if (read === void 0) {
      read = true;
    }

    let map = v => {
      if (v.id === id) v.read = read;
      return v;
    };

    if (Array.isArray(id)) {
      map = v => {
        if (id.includes(v.id)) v.read = read;
        return v;
      };
    }

    setNotifications(prev => prev.map(map));
  };

  const find = id => {
    return Array.isArray(id) ? notifications.filter(v => id.includes(v.id)) : notifications.find(v => v.id === id);
  };

  const add = item => {
    if (notifications.find(v => v.id === item.id)) return null;
    const newItem = decorate(item);
    setNotifications(prev => [...prev, newItem].sort(sortFn.current));
    return newItem.id;
  };

  const update = (id, item) => {
    const index = notifications.findIndex(v => v.id === id);

    if (index !== -1) {
      setNotifications(prev => {
        const nextState = [...prev];
        Object.assign(nextState[index], item, {
          createdAt: item.createdAt || Date.now()
        });
        return nextState.sort(sortFn.current);
      });
      return item.id;
    }

    return null;
  };

  const sort = compareFn => {
    sortFn.current = compareFn;
    setNotifications(prev => prev.slice().sort(compareFn));
  };

  return {
    notifications,
    clear,
    markAllAsRead,
    markAsRead,
    add,
    update,
    remove,
    // @ts-ignore fixme: overloading issue
    find,
    sort,

    get unreadCount() {
      return notifications.reduce((prev, cur) => !cur.read ? prev + 1 : prev, 0);
    }

  };
}
function decorate(item) {
  if (item.id == null) item.id = Date.now().toString(36).substring(2, 9);
  if (!item.createdAt) item.createdAt = Date.now();
  if (item.read == null) item.read = false;
  return item;
} // newest to oldest

function defaultSort(l, r) {
  return r.createdAt - l.createdAt;
}

exports.decorate = decorate;
exports.useNotificationCenter = useNotificationCenter;
//# sourceMappingURL=index.js.map
